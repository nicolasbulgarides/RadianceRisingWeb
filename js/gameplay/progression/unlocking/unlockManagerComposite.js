/**
 * Class for managing unlock requirements and validation for various game content.
 *
 * This class provides methods to register, validate, and manage unlock requirements
 * for different types of content such as areas, levels, items, features, etc.
 *
 *  The class is also responsible for directing the reports of successful unlock events to the server. Report instructions are generated by the unlock report class
 *  and then the unlock manager will use the report instruction to report the event to the server.
 *
 *  The class also keeps track of all unlock events that have occured since login, as well as a separate list of unlock events which have been confirmed and unconfirmed by the server
 */
class UnlockManagerComposite {
  /**
   * Constructor for the UnlockManagerComposite class.
   * Initializes tracking arrays for different types of unlock events.
   */
  constructor() {
    // Array to track all unlock events that have occurred since login
    this.allUnlockEventsSinceLogin = [];

    // Array to track reports that have been confirmed by the server
    this.confirmedReceivedReports = [];

    // Array to track reports that have been sent but not yet confirmed
    this.sentButUnconfirmedReports = [];

    // Array to track reports that have not yet been sent to the server
    this.unsentReports = [];

    // Map of unlock requirements for different content types
    this.unlockRequirements = new Map();
  }

  /**
   * Checks if a specific content is unlocked based on registered requirements.
   * @param {string} contentType - The type of content
   * @param {string} contentId - The ID of the specific content
   * @returns {boolean} - Whether the content is unlocked
   */
  isContentUnlocked(contentType, contentId) {
    const key = `${contentType}:${contentId}`;
    const requirements = this.unlockRequirements.get(key);

    if (!requirements) {
      // If no requirements are registered, default to unlocked
      return true;
    }

    // Check if all requirements are met
    return requirements.every((req) => this.isRequirementMet(req));
  }

  /**
   * Checks if a specific requirement is met.
   * @param {Object} requirement - The requirement object to check
   * @returns {boolean} - Whether the requirement is met
   */
  isRequirementMet(requirement) {
    // Placeholder implementation
    // In a real implementation, this would check against game state
    return true;
  }

  processAccomplishmentAndPossiblyCreateUnlockEvent(
    accomplishmentDataComposite
  ) {
    let accomplishmentHeader = accomplishment;
  }

  //<============================================================Later on / pre deployment core areas============================================================

  /**
   * Placeholder / to do before deployment - store  a validated unlock event in local storage
   * this allows the player to continue playing the game even if the server is down or the player is offline
   * @param {Object} unlockEvent - The unlock event to store
   */
  writeUnlockEventToLocalStorage(unlockEvent) {
    // Placeholder for actual local storage implementation
    try {
      // In a real implementation, this would use localStorage, IndexedDB, or another storage mechanism
      console.log("Writing unlock event to local storage:", unlockEvent);

      // Example implementation using localStorage:
      // const existingEvents = JSON.parse(localStorage.getItem('unlockEvents') || '[]');
      // existingEvents.push(unlockEvent);
      // localStorage.setItem('unlockEvents', JSON.stringify(existingEvents));
    } catch (error) {
      console.error("Failed to write unlock event to local storage:", error);
    }
  }

  /**
   * Placeholder / to do before deployment - fail save in case of networking issues for player
   * Loads unlock events from local storage on startup.
   */
  loadUnlockEventsFromLocalStorage() {
    // Placeholder for actual local storage implementation
    try {
      console.log("Loading unlock events from local storage");

      // Example implementation:
      // const storedEvents = JSON.parse(localStorage.getItem('unlockEvents') || '[]');
      //
      // // Sort events into appropriate arrays
      // for (const event of storedEvents) {
      //     this.allUnlockEventsSinceLogin.push(event);
      //
      //     if (event.confirmed) {
      //         this.confirmedReceivedReports.push(event);
      //     } else if (event.sent) {
      //         this.sentButUnconfirmedReports.push(event);
      //     } else {
      //         this.unsentReports.push(event);
      //     }
      // }
    } catch (error) {
      console.error("Failed to load unlock events from local storage:", error);
    }
  }

  /**
   * Registers an unlock event and adds it to the tracking arrays.
   * @param {Object} unlockEvent - The unlock event to register
   */
  registerUnlockEvent(unlockEvent, sendReportImmediately) {
    // Add to all events since login
    this.allUnlockEventsSinceLogin.push(unlockEvent);

    // Add to unsent reports for later processing
    this.unsentReports.push(unlockEvent);

    // Write to local storage
    this.writeUnlockEventToLocalStorage(unlockEvent);

    if (sendReportImmediately) {
      // Process the event immediately if needed for special / high value and important unlock events
      this.processUnsentReports();
    }
  }
  //<==================Placeholder / to do before deployment================== - this needs to be fixed to keep track of both the outbound to server id and the received from server confirmation id
  /**
   * Handles server confirmation of an unlock report.
   * @param {string} unlockEventId - The ID of the unlock event
   * @param {boolean} success - Whether the server confirmed the report
   */
  handleServerConfirmation(unlockEventId, success) {
    // Find the event in the sent-but-unconfirmed list
    const eventIndex = this.sentButUnconfirmedReports.findIndex(
      (event) => event.id === unlockEventId
    );

    if (eventIndex === -1) {
      console.warn(
        `Unlock event with ID ${unlockEventId} not found in sent-but-unconfirmed list`
      );
      return;
    }

    const event = this.sentButUnconfirmedReports[eventIndex];

    // Remove from sent-but-unconfirmed
    this.sentButUnconfirmedReports.splice(eventIndex, 1);

    if (success) {
      // Add to confirmed list
      this.confirmedReceivedReports.push(event);

      // Update local storage to reflect confirmation
      this.updateConfirmedEventInLocalStorage(event);
    } else {
      // If failed, add back to unsent for retry
      this.unsentReports.push(event);
      console.warn(
        `Failed to confirm unlock event with ID ${unlockEventId}, will retry`
      );
    }
  }

  /**
   * Sends a report to the server using the networking API.
   * @param {Object} unlockEvent - The unlock event to report
   */
  sendReportToServer(unlockEvent) {
    // Move from unsent to sent-but-unconfirmed
    this.sentButUnconfirmedReports.push(unlockEvent);

    // Generate the report instruction using the UnlockReporter
    const reportInstruction =
      unlockEvent.assembleUnlockReportInstruction(unlockEvent);

    // Placeholder for sending to the networking API
    this.sendToNetworkingAPI(reportInstruction, unlockEvent);
  }

  /**
   * Placeholder method for sending reports to the networking API.
   * @param {Object} reportInstruction - The instruction to send
   * @param {Object} unlockEvent - The associated unlock event
   */
  sendToNetworkingAPI(reportInstruction, unlockEvent) {
    // Placeholder for actual API call
    // In a real implementation, this would call the central API manager
    console.log("Sending unlock report to server:", reportInstruction);

    // Simulate a successful response for testing
    setTimeout(() => {
      this.handleServerConfirmation(unlockEvent.id, true);
    }, 1000);
  }

  evaluateTardinessOfSentButUnconfirmedReports() {
    // to do - evaluate the tardiness of the sent but unconfirmed reports and resend if necessary
  }

  /**
   * Processes unsent reports and attempts to send them to the server.
   */
  processUnsentReports() {
    if (this.unsentReports.length === 0) {
      return;
    }

    // Process each unsent report
    const reportsToProcess = [...this.unsentReports];
    this.unsentReports = [];

    for (const report of reportsToProcess) {
      this.sendReportToServer(report);
    }
  }
}
