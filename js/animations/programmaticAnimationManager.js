/**
 * Central manager for handling all programmatic animations in the application.
 * Maintains registries of animations and sequences, handles their lifecycle,
 * and provides methods for animation lookup and management.
 */
class ProgrammaticAnimationManager {
  constructor() {
    // Maps keyed by scene with an array of animations.
    this.activeAnimationsByScene = new Map();
    this.readyAnimationsByScene = new Map();

    // Additional Maps for Animation Sequences (per Scene)
    this.activeAnimationSequencesByScene = new Map();
    this.readyAnimationSequencesByScene = new Map();
  }

  // Registers an animation for a given scene. Specify if it should be active immediately.
  registerAnimation(scene, animation, isActive = false) {
    const targetMap = isActive
      ? this.activeAnimationsByScene
      : this.readyAnimationsByScene;
    if (!targetMap.has(scene)) {
      targetMap.set(scene, []);
    }
    targetMap.get(scene).push(animation);
  }

  // Deregisters an animation from both active and ready arrays for a given scene.
  deregisterAnimation(scene, animation) {
    [this.activeAnimationsByScene, this.readyAnimationsByScene].forEach(
      (map) => {
        if (map.has(scene)) {
          const animations = map.get(scene);
          map.set(
            scene,
            animations.filter((a) => a !== animation)
          );
        }
      }
    );
  }

  // Moves an animation from one group to the other.
  // For example, when an animation finishes, you might move it from active to ready.
  moveAnimation(scene, animation, toActive = true) {
    const sourceMap = toActive
      ? this.readyAnimationsByScene
      : this.activeAnimationsByScene;
    const destinationMap = toActive
      ? this.activeAnimationsByScene
      : this.readyAnimationsByScene;

    if (sourceMap.has(scene)) {
      const animations = sourceMap.get(scene);
      if (animations.includes(animation)) {
        // Remove from the source group.
        sourceMap.set(
          scene,
          animations.filter((a) => a !== animation)
        );

        // Add to the destination group.
        if (!destinationMap.has(scene)) {
          destinationMap.set(scene, []);
        }
        destinationMap.get(scene).push(animation);
      }
    }
  }

  // Example: Mark an animation as finished, moving it from active to ready.
  markAnimationFinished(scene, animation) {
    this.moveAnimation(scene, animation, false);
  }

  markAnimationAsReady(scene, animation) {
    this.moveAnimation(scene, animation, true);
  }

  // Registers an animation sequence for a given scene.
  // The 'isActive' flag determines whether the sequence should be immediately active.
  registerAnimationSequence(scene, animationSequence, isActive = false) {
    const targetMap = isActive
      ? this.activeAnimationSequencesByScene
      : this.readyAnimationSequencesByScene;
    if (!targetMap.has(scene)) {
      targetMap.set(scene, []);
    }
    targetMap.get(scene).push(animationSequence);
  }

  // Deregisters an animation sequence from both active and ready arrays for a given scene.
  deregisterAnimationSequence(scene, animationSequence) {
    [
      this.activeAnimationSequencesByScene,
      this.readyAnimationSequencesByScene,
    ].forEach((map) => {
      if (map.has(scene)) {
        const sequences = map.get(scene);
        map.set(
          scene,
          sequences.filter((seq) => seq !== animationSequence)
        );
      }
    });
  }

  // Moves an animation sequence from one group to the other for a given scene.
  // For example, when an animation sequence finishes, you might move it from active to ready.
  moveAnimationSequence(scene, animationSequence, toActive = true) {
    const sourceMap = toActive
      ? this.readyAnimationSequencesByScene
      : this.activeAnimationSequencesByScene;
    const destinationMap = toActive
      ? this.activeAnimationSequencesByScene
      : this.readyAnimationSequencesByScene;

    if (sourceMap.has(scene)) {
      const sequences = sourceMap.get(scene);
      if (sequences.includes(animationSequence)) {
        // Remove the sequence from the source group.
        sourceMap.set(
          scene,
          sequences.filter((seq) => seq !== animationSequence)
        );

        // Add the sequence to the destination group.
        if (!destinationMap.has(scene)) {
          destinationMap.set(scene, []);
        }
        destinationMap.get(scene).push(animationSequence);
      }
    }
  }

  // Marks an animation sequence as finished by moving it from active to ready.
  markAnimationSequenceFinished(scene, animationSequence) {
    this.moveAnimationSequence(scene, animationSequence, false);
  }

  //<=======================Unused

  /** 
   * Placeholder generated by ChatGPT 2-22-2025 - note animations don't specifically have a type as is but a sort of abstract wrapper "ProgrammaticAnimation", 
   * so this method is not yet active though in theory it could be useful
  // Retrieves all animations of a certain type for a given scene, from both active and ready groups.
  retrieveAllAnimationsOfRequestedType(scene, animationType) {
    const result = [];
    if (this.readyAnimationsByScene.has(scene)) {
      result.push(
        ...this.readyAnimationsByScene
          .get(scene)
          .filter((a) => a.animationType === animationType)
      );
    }
    if (this.activeAnimationsByScene.has(scene)) {
      result.push(
        ...this.activeAnimationsByScene
          .get(scene)
          .filter((a) => a.animationType === animationType)
      );
    }
    return result;
  }
*/

  /** 
  // Retrieves all animation sequences of a certain type for a given scene,
  // searching both active and ready groups.
  retrieveAllAnimationSequencesOfRequestedType(scene, animationSequenceType) {
    const result = [];
    if (this.readyAnimationSequencesByScene.has(scene)) {
      result.push(
        ...this.readyAnimationSequencesByScene
          .get(scene)
          .filter((seq) => seq.animationSequenceType === animationSequenceType)
      );
    }
    if (this.activeAnimationSequencesByScene.has(scene)) {
      result.push(
        ...this.activeAnimationSequencesByScene
          .get(scene)
          .filter((seq) => seq.animationSequenceType === animationSequenceType)
      );
    }
    return result;
  }
*/
}
