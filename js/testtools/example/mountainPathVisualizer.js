/**
 * MountainPathVisualizer provides utilities to visualize the paths and grid
 * of levels generated by the MountainPathGenerator.
 *
 * This class helps with debugging and understanding the path generation algorithms
 * by creating visual representations of the grid, mountains, and optimal paths.
 */
class MountainPathVisualizer {
  /**
   * Visualizes a grid with mountains and path in a scene
   * @param {Array} grid - 2D grid representation
   * @param {Array} path - Array of path points
   */
  static visualizeGridInScene(grid, path) {
    if (!grid || !path) return;

    // Get the current scene
    const scene =
      FundamentalSystemBridge["renderSceneSwapper"].getActiveGameLevelScene();
    if (!scene) return;

    this.clearPreviousVisualizations(scene);

    // Create a parent node for all visualization objects
    const visualRoot = new BABYLON.TransformNode("gridVisualization", scene);

    // Set visualization elevation slightly higher to avoid z-fighting
    const visualizationHeight = 0.05; // Raise visualization above ground level

    // Visualize the grid cells
    for (let z = 0; z < grid.length; z++) {
      for (let x = 0; x < grid[z].length; x++) {
        const cellType = grid[z][x];

        // Create a plane for each cell
        const cellPlane = BABYLON.MeshBuilder.CreateGround(
          `visual_cell_${x}_${z}`,
          { width: 0.9, height: 0.9 },
          scene
        );

        cellPlane.position = new BABYLON.Vector3(x, visualizationHeight, z); // Above ground
        cellPlane.parent = visualRoot;

        // Apply different materials based on cell type
        const cellMaterial = new BABYLON.StandardMaterial(
          `visual_cellMat_${x}_${z}`,
          scene
        );

        switch (cellType) {
          case "S": // Start
            cellMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green
            cellMaterial.emissiveColor = new BABYLON.Color3(0, 0.5, 0); // Slight glow
            break;
          case "E": // End
            cellMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Red
            cellMaterial.emissiveColor = new BABYLON.Color3(0.5, 0, 0); // Slight glow
            break;
          case "M": // Mountain
            cellMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3); // Dark gray
            break;
          default: // Empty space
            cellMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Light gray
            break;
        }

        cellMaterial.alpha = 0.4; // More transparent to avoid conflicts
        cellPlane.material = cellMaterial;
      }
    }

    // Visualize the path with a line
    if (path && path.length > 1) {
      const pathPoints = path.map(
        (point) =>
          new BABYLON.Vector3(point.x, visualizationHeight + 0.02, point.z)
      );

      // Create a Path3D object
      const babylonPath = new BABYLON.Path3D(pathPoints);

      // Create a line mesh for the path
      const pathLine = BABYLON.MeshBuilder.CreateLines(
        "visual_pathLine",
        { points: pathPoints, updatable: false },
        scene
      );

      // Make the path stand out
      pathLine.color = new BABYLON.Color3(0, 0.8, 1); // Cyan blue
      pathLine.parent = visualRoot;

      // Create small spheres at each path point for better visibility
      pathPoints.forEach((point, index) => {
        // Skip start and end (they already have markers)
        if (index === 0 || index === pathPoints.length - 1) return;

        const pointMarker = BABYLON.MeshBuilder.CreateSphere(
          `visual_pathPoint_${index}`,
          { diameter: 0.15 },
          scene
        );

        pointMarker.position = new BABYLON.Vector3(
          point.x,
          visualizationHeight + 0.05,
          point.z
        );
        pointMarker.material = new BABYLON.StandardMaterial(
          `visual_pathPointMat_${index}`,
          scene
        );
        pointMarker.material.diffuseColor = new BABYLON.Color3(0, 0.6, 1);
        pointMarker.material.emissiveColor = new BABYLON.Color3(0, 0.3, 0.5); // Give it a glow
        pointMarker.material.alpha = 0.7;
        pointMarker.parent = visualRoot;
      });
    }

    console.log("Grid visualization complete");
    return visualRoot;
  }

  /**
   * Clears previous visualization objects from the scene
   * @param {BABYLON.Scene} scene - The scene to clear visualizations from
   */
  static clearPreviousVisualizations(scene) {
    // Find and dispose existing visualization node
    const existingVisual = scene.getTransformNodeByName("gridVisualization");
    if (existingVisual) {
      // Dispose of all the visualization's children
      existingVisual.getChildren().forEach((child) => {
        if (child.material) {
          child.material.dispose();
        }
        child.dispose();
      });
      existingVisual.dispose();
    }
  }

  /**
   * Creates a 3D visual representation of a mountain at the specified position
   * @param {BABYLON.Scene} scene - The scene to add the mountain to
   * @param {number} x - X position
   * @param {number} z - Z position
   * @returns {BABYLON.Mesh} The created mountain mesh
   */
  static createMountainMesh(scene, x, z) {
    // Create a mountain representation (cone)
    const mountain = BABYLON.MeshBuilder.CreateCylinder(
      `fallback_mountain_${x}_${z}`,
      {
        diameterTop: 0,
        diameterBottom: 0.7,
        height: 1.0,
        tessellation: 6, // Hexagonal base
      },
      scene
    );

    mountain.position = new BABYLON.Vector3(x, 0.5, z);

    // Create a mountain material
    const mountainMaterial = new BABYLON.StandardMaterial(
      `fallback_mountainMat_${x}_${z}`,
      scene
    );
    mountainMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.3, 0.2); // Brown-ish
    mountainMaterial.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
    mountainMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0);

    mountain.material = mountainMaterial;

    return mountain;
  }

  /**
   * Logs the grid to the console in a readable format
   * @param {Array} grid - 2D grid representation
   * @param {Array} path - Optional path to highlight
   */
  static logGridToConsole(grid, path = null) {
    if (!grid) return;

    // Create a copy of the grid to mark the path
    const displayGrid = grid.map((row) => [...row]);

    // Mark path on the grid with '*'
    if (path) {
      path.forEach((point) => {
        // Skip start and end points
        if (
          displayGrid[point.z][point.x] !== "S" &&
          displayGrid[point.z][point.x] !== "E"
        ) {
          displayGrid[point.z][point.x] = "*";
        }
      });
    }

    // Build console output
    console.log("Grid Visualization:");
    console.log("S = Start, E = End, M = Mountain, * = Path, . = Empty");
    console.log("-".repeat(displayGrid[0].length * 2 + 1));

    for (let z = 0; z < displayGrid.length; z++) {
      let row = "|";
      for (let x = 0; x < displayGrid[z].length; x++) {
        row += displayGrid[z][x] + "|";
      }
      console.log(row);
      console.log("-".repeat(displayGrid[0].length * 2 + 1));
    }
  }

  /**
   * Enhances a MountainPathGenerator instance with visualization methods
   * @param {MountainPathGenerator} generator - The generator to enhance
   */
  static enhanceGenerator(generator) {
    // Store the original methods
    const originalGenerateObstacles = generator.generateMountainObstacles;
    const originalFindPath = generator.findPath;

    // Override the generate obstacles method to add visualization
    generator.generateMountainObstacles = function (...args) {
      const [grid, startPosition, endPosition, width, depth, obstacleRatio] =
        args;

      // Call the original method
      const path = this.findPath(
        grid,
        Math.floor(startPosition.x),
        Math.floor(startPosition.z),
        Math.floor(endPosition.x),
        Math.floor(endPosition.z)
      );

      // Visualize the initial grid and path
      console.log("Initial grid with start and end positions:");
      MountainPathVisualizer.logGridToConsole(grid, path);

      // Continue with the original method
      const obstacles = originalGenerateObstacles.apply(this, args);

      // Visualize the final grid with mountains
      console.log("Final grid with mountains and path:");
      MountainPathVisualizer.logGridToConsole(grid, path);

      // Add a method to the obstacles to get the path
      obstacles.path = path;
      obstacles.grid = grid;

      return obstacles;
    };

    // Add a visualization method
    generator.visualizeCurrentLevel = function (gameplayLevel) {
      if (!this.lastGrid || !this.lastPath) {
        console.warn("No grid or path to visualize");
        return;
      }

      MountainPathVisualizer.visualizeGridInScene(this.lastGrid, this.lastPath);
    };

    return generator;
  }

  /**
   * Creates 3D mountains directly in the scene when standard obstacles fail
   * @param {Array} grid - The grid representation
   * @param {BABYLON.Scene} scene - The scene to add mountains to
   * @returns {BABYLON.TransformNode} The parent node for all mountains
   */
  static createFallbackMountains(grid, scene) {
    if (!grid || !scene) return null;

    console.log("Creating fallback 3D mountains...");

    // Clear any previous fallback mountains
    const existingMountains = scene.getTransformNodeByName("fallbackMountains");
    if (existingMountains) {
      existingMountains.getChildren().forEach((child) => {
        if (child.material) {
          child.material.dispose();
        }
        child.dispose();
      });
      existingMountains.dispose();
    }

    // Create parent node
    const mountainsRoot = new BABYLON.TransformNode("fallbackMountains", scene);

    // Create mountains based on grid
    let mountainCount = 0;

    for (let z = 0; z < grid.length; z++) {
      for (let x = 0; x < grid[z].length; x++) {
        if (grid[z][x] === "M") {
          const mountain = this.createMountainMesh(scene, x, z);
          mountain.parent = mountainsRoot;
          mountainCount++;
        }
      }
    }

    console.log(`Created ${mountainCount} fallback mountains`);
    return mountainsRoot;
  }

  /**
   * Visualizes the grid and creates fallback mountains if needed
   * @param {Array} grid - 2D grid representation
   * @param {Array} path - Array of path points
   * @param {boolean} createMountains - Whether to create 3D mountains
   */
  static visualizeFullGrid(grid, path, createMountains = true) {
    if (!grid || !path) return;

    // Get the current scene
    const scene =
      FundamentalSystemBridge["renderSceneSwapper"].getActiveGameLevelScene();
    if (!scene) return;

    // Create the visual grid
    this.visualizeGridInScene(grid, path);

    // Create fallback 3D mountains if requested
    if (createMountains) {
      this.createFallbackMountains(grid, scene);
    }
  }
}
